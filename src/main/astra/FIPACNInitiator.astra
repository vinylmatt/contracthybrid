agent FIPACNInitiator extends FIPAContractNet {
    types cnp_initiator {
        formula participant(string);
        formula awarded(string, string);
        formula best_bid(string, string, int);
        formula completed(string, boolean);
    }

    // DELIBERATION RULES
    rule +contract(string id, string type, list params, int deadline) {
        !awarded(id, string winner);
    }

    // MEANS END REASONING RULES
    rule +!awarded(string id, string winner) : awarded(id, string awardee) {
        winner = awardee;
    }

    rule +!awarded(string id, string winner) : contract(id, string type, list params, int deadline) {
        foreach(participant(string participant)) {
            send(cfp, participant, contract(id, type, params, deadline));
        }

        // Wait till deadline for bids...
        system.sleep(deadline);

        // Find the best bid...      
        foreach(bid(id, string participant, int value)) {
            !best_bid(id, participant, value);
        }

        // Respond to proposals...
        query(best_bid(id, string best_bidder, int best_bid));
        send(accept-proposal, best_bidder, bid(id, best_bidder, best_bid));
        // Optional: Remove bids (tidying up beliefs generated by the auction)
        // -bid(id, best_bidder, best_bid);
        foreach (participant(string name) & bid(id, name, int bid) & (name ~= best_bidder)) {
            send(reject-proposal, name, bid(id, name, bid));

            // Optional: Remove bids (tidying up beliefs generated by the auction)
            //-bid(id, name, bid);
        }

        // Return name of winner...
        +awarded(id, best_bidder);
        winner = best_bidder;
    }

    /**
     * Default bid assessment strategy bigger == better
     * can be overridden in subclasses...
     */
    rule +!best_bid(string id, string bidder, int value) : 
            best_bid(id, string best_bidder, int best_value) {
        if (value > best_value) {
            -+best_bid(id, bidder, value);
        }
    }

    rule +!best_bid(string id, string bidder, int value) : 
            contract(id, string type, list params, int deadline) {
        +best_bid(id, bidder, value);
    }

    rule @message(propose, string sender, bid(string id, sender, int value)) : participant(sender) {
        +bid(id, sender, value);
    }

    rule @message(inform, string sender, fulfilled(string id, string type, list params)) {
        !completed(id, true);
    }

    rule @message(failure, string sender, contract(string id, string type, list params, int deadline)) {
        !completed(id, false);
    }

    /**
     * Default behaviour is to adopt the corresponding belief which causes the agent to clear all beliefs
     * This rule can be overriden to introduce more complex handling of failure
     */
     rule +!completed(string id, boolean outcome) {
         +completed(id, outcome);
     }

    // Optional: Removal of all code (including this belief)
    // rule +completed(string id, boolean outcome) : 
    //         contract(id, string type, list params, int deadline) &
    //         best_bid(id, string sender, int value) {
    //     -completed(id, outcome);
    //     -awarded(id, sender);
    //     -best_bid(id, sender, value);
    //     -contract(id, type, params, deadline);
    // }
}