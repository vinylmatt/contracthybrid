agent FIPACNInitiator extends FIPAContractNet {
    module Console c;
    module EIS ei;
    types cnp_initiator {
        formula participant(string);
        formula awarded(int, string);
        formula best_bid(int, string, int);
        formula completed(int, boolean);
        
    }

    // DELIBERATION RULES
    rule +contract(int id, string type, list params, int deadline) {
        !awarded(id, string winner);
    }

    // MEANS END REASONING RULES
    rule +!awarded(int id, string winner) : awarded(id, string awardee) {
        winner = awardee;
    }

    rule +!awarded(int id, string winner) : contract(id, string type, list params, int deadline) {
        foreach(participant(string participant)) {
            send(cfp, participant, contract(id, type, params, deadline));
        }

        // Wait till deadline for bids...
        system.sleep(deadline);

        // Find the best bid...      
        foreach(bid(id, string participant, int value)) {
            !best_bid(id, participant, value);
        }

        // Respond to proposals...
        query(best_bid(id, string best_bidder, int best_bid));
        send(accept-proposal, best_bidder, bid(id, best_bidder, best_bid));
        // Optional: Remove bids (tidying up beliefs generated by the auction)
        -bid(id, best_bidder, best_bid);
        foreach (participant(string name) & bid(id, name, int bid) & (name ~= best_bidder)) {
            send(reject-proposal, name, bid(id, name, bid));

            // Optional: Remove bids (tidying up beliefs generated by the auction)
            //-bid(id, name, bid);
        }

        // Return name of winner...
        +awarded(id, best_bidder);
        c.println("..............................................CONTRACT AWARDED TO ID "+id+". best bidder: "+best_bidder+"");
        winner = best_bidder;
    }

    /**
     * Default bid assessment strategy bigger == better
     * can be overridden in subclasses...
     */
    rule +!best_bid(int id, string bidder, int value) : 
            best_bid(id, string best_bidder, int best_value) {
        if (value > best_value) {
            -+best_bid(id, bidder, value);
        }
    }

    rule +!best_bid(int id, string bidder, int value) : 
            contract(id, string type, list params, int deadline) {
        +best_bid(id, bidder, value);
    }

    rule @message(propose, string sender, bid(int id, sender, int value)) : participant(sender) {
        +bid(id, sender, value);
    }

    rule @message(inform, string sender, fulfilled(int id, string type, list params)) {
        !completed(id, true);
    }

    rule @message(failure, string sender, contract(int id, string type, list params, int deadline)) {
        !completed(id, false);
    }

    /**
     * Default behaviour is to adopt the corresponding belief which causes the agent to clear all beliefs
     * This rule can be overriden to introduce more complex handling of failure
     */
     rule +!completed(int id, boolean outcome) {
         +completed(id, outcome);
     }

    // Optional: Removal of all code (including this belief)
    rule +completed(int id, boolean outcome) : 
            contract(id, string type, list params, int deadline) &
             best_bid(id, string sender, int value) {
         -completed(id, outcome);
        -awarded(id, sender);
        -best_bid(id, sender, value);
        -contract(id, type, params, deadline);

    }

    rule +!orient(long X, long Y,string name) : ei.location(long A, long B) & ei.direction(string direction)  {		

		if (direction == "north") {
			if (name == "left") 			{	A = A-1; 			!makecontract(A,B);	
							
				}
			if (name == "forwardLeft") 		{  A =A-1;	B =B-1;		!makecontract(A,B); 	
							
				}
			if (name == "forward") 			{  B =B-1;  			!makecontract(A,B); 	
							
				}
			if (name == "forwardRight") 	{  A= A+1; B= B-1;		!makecontract(A,B); 	
							
				}
			if (name == "right") 			{  A= A+1; 				!makecontract(A,B); 	
				//c.println("Square "+ name +", at "+ A +" y= "+ B +" auctioning....  .");			
				}
  			}
			
	    if (direction == "south") {
				if (name == "left") {  				A = A+1; 			!makecontract(A,B);	
								
					}
				if (name == "forwardLeft") 		{  	A= A+1; B= B+1;		!makecontract(A,B); 	
								
					}
				if (name == "forward") 			{  B =B+1;  			!makecontract(A,B); 	
								
					}
				if (name == "forwardRight") 	{  A= A-1; B= B+1;		!makecontract(A,B); 	
								
					}
				if (name == "right") 			{  A= A-1; 				!makecontract(A,B); 	
								
					}
			}


	    if (direction == "east") {		
				if (name == "left") {  				B = B-1; 			!makecontract(A,B);	
					//c.println("Square "+ name +", at "+ A +" y= "+ B +" auctioning..... ");			
					}
				if (name == "forwardLeft") 		{  	A= A+1;B= B-1;		!makecontract(A,B); 	
								
					}
				if (name == "forward") 			{  A= A+1;	 			!makecontract(A,B); 	
								
					}
				if (name == "forwardRight") 	{  A= A+1;	B= B+1;		!makecontract(A,B); 	
								
					}
				if (name == "right") 			{  B= B+1; 				!makecontract(A,B); 	
						
						}
			}

	    if (direction == "west") {	

				if (name == "left")				{  	B = B+1; 			!makecontract(A,B);	
								
					}
				if (name == "forwardLeft") 		{  	A= A-1;	B= B+1;		!makecontract(A,B); 	
								
					}
				if (name == "forward") 			{  A= A-1;				!makecontract(A,B); 	
								
					}
				if (name == "forwardRight") 	{  A= A-1;	B= B-1;		!makecontract(A,B); 	
								
					}
				if (name == "right") 			{  B= B-1; 				!makecontract(A,B); 	
					
						}
			}
	}
}